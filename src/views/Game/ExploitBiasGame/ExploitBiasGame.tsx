import style from './style.module.css';
import { useTranslation } from 'react-i18next';
import Header from '../../../components/Header/Header';
import Footer from '../../../components/Footer/Footer';
import { useEffect, useState } from 'react';
import { useAtom } from 'jotai';
import { modelAtom, classificationResultAtom, scoresAtom } from '../../../atoms/state';
import { Button, Webcam } from '@knicos/genai-base';
import { loadMobileNetModel } from '../../../services/loadModel';
import { classifyImage } from '../../../utils/classifyImage';
import { useNavigate } from 'react-router-dom';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import PauseIcon from '@mui/icons-material/Pause';

const BASELINETIME = 5;

/**
 * Bias game with own images using live webcam classification
 * @returns ExploitBiasGame view
 */
export default function ExploitBiasGame() {
    //const classTerms = ['prison', 'monitor', 'pizza', 'book']; // TODO: Korvataan ammateilla sitten joskus
    const classTerms = ['monitor', 'prison'];
    const { t } = useTranslation();
    const navigate = useNavigate();
    const [webcamSize, setWebcamSize] = useState(Math.min(Math.floor(window.innerWidth * 0.8), 800)); // Size of the webcam component
    const [model, setModel] = useAtom(modelAtom);
    const [, setClassificationResult] = useAtom(classificationResultAtom);
    const [scores, setScores] = useAtom(scoresAtom);
    const [score, setScore] = useState(0);
    const [currentScore, setCurrentScore] = useState(0);
    const [classifyTerm, setClassifyTerm] = useState('');
    const [isCameraActive, setIsCameraActive] = useState(false);
    const [captureOn, setCameraOn] = useState(false);
    const [restart, setRestart] = useState(false);
    const [phase, setPhase] = useState(0);
    const [level, setLevel] = useState(1);
    const [secondsLeft, setSecondsLeft] = useState(0);
    const [topCanvas, setTopCanvas] = useState<HTMLCanvasElement | null>(null);

    // Ladataan malli tarvittaessa
    useEffect(() => {
        if (!model) {
            loadMobileNetModel().then(setModel);
        }
        setClassificationResult(null);
    }, [model, setModel, setClassificationResult]);

    // Webcam's size adjustment on window resize
    useEffect(() => {
        const handleResize = () => {
            setWebcamSize(Math.min(Math.floor(window.innerWidth * 0.8), 800));
        };
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    // Starting baseline counter
    useEffect(() => {
        if (secondsLeft <= 0) {
            moveToNextPhase();
            return;
        }
        const interval = setInterval(() => {
            setSecondsLeft((prev) => prev - 1);
        }, 1000);
        return () => clearInterval(interval);
    }, [restart, secondsLeft, setSecondsLeft]);

    const getNextTerm = (index: number): string => {
        return classTerms[index];
    };

    // Luokittelu canvas-kuvasta
    const handleCapture = async (canvas: HTMLCanvasElement) => {
        if (!model) return;
        try {
            const results = await classifyImage(model, canvas, 100);
            const result = results.filter((r) => r.className.toLowerCase().includes(`${classifyTerm}`));
            if ((phase === 1 || phase === 2) && result.length > 0) {
                const currentScore = Math.floor(result[0].probability * 10000) / 100;
                setCurrentScore(currentScore);
                if (score < currentScore) {
                    setScore(currentScore);
                    setTopCanvas(canvas);
                    console.log(currentScore);
                }
            }
            setClassificationResult(results.slice(0, 3)); // Top 3
        } catch (err) {
            console.error('Luokittelu epäonnistui:', err);
            setClassificationResult(null);
        }
    };

    /**
     * Handles moving to next term and saves the scores and images to atom.
     * Consider saving to localstorage as mobiledevices easily refresh accidently?...
     */
    const moveToNextPhase = () => {
        if (phase === 0) {
            setScores([]);
            setCameraOn(true);
            setPhase(1);
            setClassifyTerm(getNextTerm(0));
            setSecondsLeft(BASELINETIME);
            setRestart((prev) => !prev);
        } else if (phase === 1) {
            // save lowscore from phase 2
            setScores([
                ...scores,
                { className: classifyTerm, lowScore: score, topScore: 0, topCanvas: null, topHeatmap: null },
            ]);
            setPhase(2);
        } else if (phase === 2) {
            // update the atomic scores
            const updatedScores = scores.map((s) =>
                s.className === classifyTerm
                    ? { ...s, topScore: score, topCanvas: topCanvas, topHeatmap: topCanvas }
                    : s
            );
            setScores(updatedScores);

            // Move to next classify term
            const nextLevel = level + 1;
            setLevel(nextLevel);
            if (nextLevel > classTerms.length) {
                setCameraOn(false);
                setPhase(3);
                setScore(0);
                return;
            } else {
                setClassifyTerm(getNextTerm(nextLevel - 1));
                setPhase(1);
                setSecondsLeft(BASELINETIME);
                setRestart((prev) => !prev);
            }
        }
        setScore(0);
    };

    const moveToScores = () => {
        navigate('/game/own/scores');
    };

    return (
        <div className={style.container}>
            <Header title={t('common.title')} />
            <div className={style.innerContainer}>
                <div className={style.innerContainer}>
                    <h2>{classifyTerm && `Luokittelusana: \n${classifyTerm}`}</h2>
                    {!isCameraActive && (
                        <div className={style.cameraNotActive}>{t('webcam.notAvailable', 'Kamera käynnistyy')}</div>
                    )}
                    <div className={style.scoreBarContainer}>
                        <div className={style.currentScoreBar}>
                            <span style={{ width: `${Math.round(currentScore)}%` }}></span>
                        </div>
                        <div className={style.scoreBar}>
                            <span style={{ width: `${Math.round(score)}%` }}></span>
                        </div>

                        <div
                            className={style.scoreBarToolTip}
                            style={{ width: `${Math.round(score)}%` }}
                        >
                            <span data-label={score}></span>
                        </div>
                        <div
                            className={style.scoreBarCurrentToolTip}
                            style={{ width: `${Math.round(currentScore)}%` }}
                        >
                            <span data-label={currentScore}></span>
                        </div>
                    </div>
                    <div className={`${style.webcamWrapper} ${phase === 1 ? style.baseline : style.filtered}`}>
                        {phase === 1 && <div className={style.overlayText}>Evaluating baseline: {secondsLeft}s</div>}
                        <Webcam
                            size={webcamSize}
                            interval={100}
                            capture={captureOn}
                            disable={!captureOn}
                            onCapture={handleCapture}
                            hidden={false}
                            onActivated={setIsCameraActive}
                            onFatal={() => console.error('Webcam failure')}
                        />
                    </div>
                    {phase > 1 && (
                        <Button
                            sx={{ fontSize: '14pt', minWidth: '40px', marginTop: '6px' }}
                            variant="contained"
                            onClick={() => {
                                setCameraOn((prev) => !prev);
                            }}
                        >
                            {captureOn ? <PauseIcon /> : <PlayArrowIcon />}
                        </Button>
                    )}
                    {phase !== 3 && phase !== 1 && (
                        <Button
                            sx={{ fontSize: '14pt', minWidth: '140px', marginTop: '6px' }}
                            variant="contained"
                            onClick={moveToNextPhase}
                        >
                            {phase === 0 && 'Aloita'}
                            {phase > 1 && level < classTerms.length && 'Seuraava sana'}
                            {phase > 1 && level >= classTerms.length && 'Tallenna tulokset'}
                        </Button>
                    )}{' '}
                    {phase === 3 && (
                        <Button
                            sx={{ fontSize: '14pt', minWidth: '140px', marginTop: '16px' }}
                            variant="outlined"
                            onClick={moveToScores}
                        >
                            Siirry tuloksiin
                        </Button>
                    )}
                </div>
            </div>
            <Footer />
        </div>
    );
}
